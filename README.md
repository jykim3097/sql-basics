# sql-basics
Oracle sql

### 210329  데이터베이스 소개와 여는 내용

## 데이터베이스 소개
* 파일 형식 데이터 
	* 채팅 같은 비관계 데이터를 저장
* 관계형 모델의 구성요소
	* 개체(object) 혹은 관계(relation)의 집합
	* 관계(relation)에 가해지는 연산자의 집합
	* 정확성과 일관성을 위한 데이터 무결성
* 관계형 데이터베이스 : 관계들의 모음 또는 이차원 테이블의 모음
* 파일 시스템과 데이터베이스 시스템의 차이점
	* 무결성 유지 : 깔끔함이라고 생각하면 된다.
	* 데이터의 공유
	* 데이터의 정확성과 일관성
	* **중복성 제거** 
	* 불일치를 피할 수 있다
	* 표준화 가능
	* 데이터의 독립성 보장 : 개념화 기법 발달
	* 각 테이블은 고유한 이름을 갖는다
	* 중복 문제의 해결 기법 제공 : 정규형
	* 데이터 조작언어의 발달 : SQL
	* RDB는 테이블들의 모임으로 구성
	* 각 행은 일련의 값들 사이의 관계
* 관계형 데이터베이스는 SQL문을 사용하여 이용되고 수정된다.
* SQL문이란 데이터베이스로부터 데이터를 조회, 삭제, 수정, 변경할 때 사용하는 언어

* 데이터베이스는 다양하다
	* 오라클, MySql, MSSQL, 마리아 등
	* 우리는 오라클을 배울 것
	* 몽고db(noSql) : 엄청난 양의 파일 데이터 저장(?)
		* 비관계형 데이터베이스
* 설계할 때 부르는 말이랑 사용할 때 부르는 말이 조금 다르다
	* 표 자체 : entity, 개체 = table
	* 행 : 튜플, 레코드
	* 열 : 속성, 필드

### 관계형 데이터베이스의 키
1. 후보키 : 기본키가 될 수 있는 후보, 튜플을 유일하게 식별할 수 있는 키
	* ex) 학번, 주민번호
2. 기본키 : 후보키 중에 선택한 주 키, 튜플을 유일하게 식벽할 수 있는 키
	* ex) 학번
3. 대체키 : 후보키가 둘 이상일 때 기본키를 제외한 나머지 후보 키
	* ex) 주민번호
4. 슈퍼키 : 테이블 내에 있는 속설들의 집합으로 구성된 키(2개로 이루어진 키)
	* ex) 학번과 과목명
5. 외래키 : 참조되는 테이블의 기본키와 대응되어 참조 관계를 표현하는 키 
	* 주키가 없으면 입력할 수 없다.
* 일반 키에는 null값이 들어갈 수 있다

### 오라클 Multi-Tenant DB 
* Mulit(다중) + Tenant(세입자) : DB 안에 여러 DB가 있는 구조
* Private Cloud 형태를 DBMS 내에서 구축한 것
* CDB : Container DB - 집주인 DB
* PDB : Pluggable DB - 세입자 DB
* 시스템 상에서 보면 CDB만 보이므로 한개의 DB로 인식하고 패치, 백업등의 작업을 한번만 수행한다 = 관리가 수월하다
* DB 통합, Private Cloud 구축에 아주 유용한 기능
* 멀티 테넌트 기능은 Oracle DB만 가능
* 출처 : https://jack-of-all-trades.tistory.com/286


### 210330

## 첫 DB 만들기 in SqlDeveloper
* 실제로 접속할 곳 : PDB : 실제 사용하는 DB
* 왼쪽 위의 초록색+ 누르면 새로운 DB 생성
* Name 필드에는 database 이름(한글도 가능)
* 사용자 정보에는 내 정보
	* 최고 관리자 sys : 모든 걸 할 수 있는 권한을 갖고 있기 때문에 사용하지 않는다.
	* 항상 마스터 계정이 있고, 사용자 계정이 있다.
		* 연습용 계정 hr을 만든다.
* 세부정보에서는 어떤 db에 접속할 것인지를 작성
* SID : 건들지 않은 진짜 이름, 원본데이터 xe의 이름
* 서비스 이름 : 데이터베이스의 별칭
	* 처음에 별칭을 줬는데 그게 XEPDB1이었다
* 테스트 누르면 상태: 성공으로 바뀜
* SQL 문서는 그냥 메모장에 저장해두는 게 편하다
* 관계형 데이터베이스 : 여러 테이블이 서로 관계를 갖고 있는 것

### 접속은 항상 조심!!!!
* 회사 가면 회사 ip주소, port number, SID, 계정을 줄 것
* 이 값들만 수정해서 접속하면 된다

## 데이터베이스 용어 (CLUD)
* 크게 세가지(DML, DDL, DCL)와 TCL
* 스키마 : 테이블의 정보

### DML ( Data Manipulation Language)
#### SELECT : DB로부터 데이터 검색(조회)
#### INSERT, UPDATE, DELETE
* DB 테이블에서 새로운 행을 입력(INSERT)하고, 기존의 행을 변경(UPDATE)하고, 기존의 행을 제거(DELETE)한다.
### DDL (Data Definition Language)
#### CREATE, ALTER, DROP, RENAME, TRUNCATE
* 테이블로부터 데이터 구조를 생성(CREATE), 변경(ALTER), 제거(DROP)한다.
* 이름을 변경(RENAME)하거나 구조만 남기고 모든 데이터를 삭제(TRUNCATE)하기도 한다
### TCL (Transaction Control Language)
#### COMMIT, ROLLBACK, SAVEPOINT
* DML 명령문으로 만든 변경을 관리한다
* 데이터 변경은 논리적 트랜잭션으로 함께 그룹화될 수 있다
### DCL (Data Control Language)
#### GRANT, REVOKE
* DB에 접근하고 객체를 사용할 수 있도록 권한을 주거나 회수한다.

## DML - SELECT 문장
* DB로부터 데이터 검색(조회), **행 조회**를 한다
* 기본 틀 : SELECT ~ FROM table;
	* SELECT : 하나 이상의 열을 나열
	* DISTINCT : 중복 제거
	* * : 모든 열을 선택
	* column(= filed) : 열 선택
	* AS : 열 별칭(alias) 지정, 선택된 열을 다른 이름으로 변경
		* 공백이나 특수문자를 포함하고 있으면 쌍따옴표에 넣어 사용해야한다
	* FROM table : 열을 포함하는 테이블 명시
* select 절에는 문자 표현식이나 숫자가 포함된다
	* 날짜나 문자는 홑따옴표에 넣어 사용하고 숫자는 그냥 사용한다
	* ||로 값을 연결할 수 있다
* 기본적으로 중복을 모두 포함해서 출력되기 때문에 **distinct**를 사용해 중복 행을 제거한다

* 기본 문법
	* sql 문법은 대소문자를 구분하지 않는다
	* 키워드는 단축하거나 줄을 나눠쓸 수 없다
	* 데이터베이스의 타입은 크게 세가지 : 문자, 숫자, 날짜
		* 문자, 날짜는 왼쪽 정렬
		* 숫자는 오른쪽 정렬
	* 디폴트 열은 대문자로 출력
	* null은 이용할 수 없거나 / 지정되지 않았거나 / 알 수 없거나 / 적용할 수 없는 값
		* 숫자 0이나 공백과 다른 값
	* 숫자, 문자 모두 null이라고 표현된다

* ROWID : 데이터베이스에서 행의 주소를 반환
	* AAAEAbAAEAAAADNAAA 같은 형식
		* AAAEAb.AAE.AAAADN.AAA
		* 처음 6자리(AAAEAb) : 데이터 오브젝트 번호
		* 다음 3자리(AAE) : 상대적 파일 번호
		* 다음 6자리(AAAADN) : 블록 번호
		* 다음 3자리(AAA) : 블록 내 행 번호
* **ROWNUM** : 쿼리에 의해 반환되는 **행의 번호(출력 순서)** 출력 (아주 중요!)
	* PK가 없는 테이블에서 PK를 대신할 수 있다
	* PK가 있을 때와 없을 때 출력순서가 다르다
	* PK가 있으면 조회가 빠르다

### 데이터 제한 - WHERE절
* 조건을 만족하는 행으로 질의를 제한한다
* 문자와 날짜 값은 홑따옴표 안에 담는다
* 문자 값은 대소문자를 구분하고, 날짜 값은 날짜 형식을 구분한다
	* 날짜 표현 형식은 세기, 연, 월, 일, 시간, 분, 초 순으로 저장
* 같지 않다는 <>
* between 연산자 : 값의 범위에 해당하는 행을 출력
	* 작은 값을 먼저 입력
	* salary between 10000 and 12000; = 10000 <**=** salary <**=** 12000
* **in 연산자** : 목록에 있는 값 비교
	* 형식 ex) manager_id in(101, 102, 103)
* **like 연산자** : 검색할 때 사용
	* % : 문자가 없거나 하나 이상
	* _ : 하나의 문자, 문자의 위치
	* 형식 ex) job_id like 'IT%'
* null은 비교연산자로 찾을 수 없고, **is null, ** 연산자로 테스트한다
* 논리 연산자
* and 연산자가 or 연산자보자 연산자 우선순위가 높다 = and가 더 빨리 계산된다
### 데이터 정렬
* 검색되는 행을 정렬
* order by : select 문의 가장 뒤에 온다, 가장 나중에 실행된다
* asc : 오름차순 정렬 / desc : 내림차순 정렬
* 열 별칭을 사용할 수 있다

#### DESC (테이블이름); - 테이블 정보를 보는 키워드

### 210331

## 복습
* Sql developer는 그냥 GUI 툴이다
* 오라클은 윈도우가 켜지만 자동으로 켜지게 설정이 되어있다

### CDB
* 호스트 이름 : localhost = IP주소 = 127.0.0.1
* 포트 번호 : 실행되는 프로그램 번호
* SID : 원본 DB 이름
	* CDB가 기본적으로 xe라는 이름으로 만들어짐
* 서비스 이름 : DB 별칭

### select, from, where, order by
* where → in, like, and, or

## 함수
* select 구문에서 열 조회를 하기 위해 필요한 함수가 많다
* java에서 썼던 모든 문법들은 DB에서 다 쓸 수 있다
* sql의 아주 강력한 특징, 
	* 데이터 계산 수행
	* 개별적인 데이터 항목 수정
	* 행의 그룹에 대해 결과 조작
	* 출력을 위한 날짜와 숫자 형식 설정
	* 열의 데이터타입 변환
* 단일 행 함수 : 단일 행에서 적용 가능, 행별로 하나의 결과 리턴
	* 입력 하나, 출력 하나
	* 데이터 값 조작, 데이터타입 수정 가능
	* **중첩 가능**
	* 문자, 숫자, 날짜, 변환 함수 등이 있다.
		* 문자 함수 : 입력은 문자, 리턴은 문자, 숫자
		* 숫자 함수 : 입력 숫자, 리턴 숫자
		* 날짜 함수 : 날짜 데이터타입의 값에 대해 수행
			* months_between 함수만 숫자 리턴, 나머지 모든 함수는 날짜 데이터타입의 값 리턴
		* 변환 함수 : 데이터 타입을 변환하는 함수
			* nvl, nvl2 등
* 다중 행 함수 : 복수의 행 조작, 행의 그룹당 하나의 결과 리턴
	* 입력 여러개, 출력 하나

### 문자(열) 함수
* initcap('parameter') → Parameter : 첫문자만 대문자로, 나머지는 소문자로 출력
* lower('Parameter') → parameter : 모두 소문자로 출력
* upper('parameter') → PARAMETER : 모두 대문자로 출력
* length('parameter') → 9 : 문자열의 길이(문자의 수)를 출력
* lengthb('parameter') → 바이트 수 출력
* substr('ParaMeter',1,2) → Pa : 첫 번째 인자의 1번째 자리부터 2개의 문자 출력
* instr('parameter', 'm') → 5 : 찾는 문자의 위치 반환, **없으면 0 반환**
* lpad(17600, 10, "*") → *****17600 : 두번째 인자(자릿수)만큼 왼쪽에 세번째 인자를 채운다
* rpad
* ltrim('parameter', 'para') → meter : 첫 번째 인자에서 왼쪽 첫째자리부터 두번째 인자와 같은 값을 지운다
* ltrim(' parameter') → 'parameter' : 왼쪽 공백 지우기
* rtrim
* trim(' parameter ') → 'parameter' : 양쪽 공백 지우기
* replace('parameter', 'para', 'centi') → 'centimeter : 첫번째 인자에서 두번째 문자열을 찾아 세번째 문자열로 바꿔라
* 가상 테이블 dual

### 숫자 함수
* **round(m,n)** : 소수점 n자리까지 반올림, n이 생략되면 소수점이 없어진다. n이 음수이면 소수점의 왼쪽 자릿수만큼 반올림
	* 날짜 함수에서도 사용할 수 있다
* **trunc(m,n)** : 소수점 n자리까지 절삭, n이 생략되면 소수점이 없어진다. n이 음수이면 소수점의 왼쪽 자릿수만큼 절삭
	* 날짜 함수와 함께 사용할 수 있다
* abs : 절대값 반환
* ceil : 무조건 올림
* floor : 내림
* power(m,n) : m의 n제곱 값 리턴
* sqrt(n) : n의 제곱근 값 리턴
* mod(m,n) : m을 n으로 나눈 나머지 리턴 = m%n(java)

### 날짜 함수
* 오라클은 세기, 년, 월, 일, 시간, 분, 초 순으로 내부 숫자형식으로 날짜를 저장한다
* 디폴트 형식은 'DD-MON-YY' or 'YY/MM/DD'

* 날짜 함수를 쓸 일이 많다. 그래서 상당히 중요하지만 외울 건 하나!
* SYSDATE : 현재의 날짜를 반환한다
* SYSTIMESTAMP - 밀리초까지 보여준다
	* 현재 날짜 + 시간
* dual이라는 더미 테이블로 sysdate를 선택하는 것이 관례다
* 날짜에 숫자를 더하거나 뺄 수 있다 - DB가 날짜를 숫자로 저장하기 때문
	* 날짜 + 숫자 = 날짜 : day에 더한다
	* 날짜 - 숫자 = 날짜 : day에서 뺀다
	* 날짜 - 날짜 = 일 수 : 기준 날짜에서 오늘 날짜를 빼면 사이 기간 값이 나온다
	* 날짜 + 숫자/24 = 날짜 : 시간을 날짜에 더한다
* round, trunc 함수도 사용할 수 있다
	* round(day) : 수요일을 기준으로 수요일보다 전 날이면 그 전주 일요일로 반올림, 수요일보다 나중이면 다음주로 넘어감
	* trunc(day) : 일 기준으로 절삭하기 때문에 과거 일요일 날짜가 나온다

### (형)변환함수
* 자바로 따지자면 testing을 해주는 함수
* 쓸 일이 많기 때문에 중요하다
#### 암시적 형변환
* 문자(varchar2, char) → 숫자(number), 날짜(date)
* 숫자, 날짜 → 문자

#### 암시적 형변환이 안되는 경우
* 숫자(number) ↔ 날짜(date) 는 형변환이 **한번에 안된다**
* 그렇기 때문에 문자(character)를 기준으로 한번 거치는 작업을 해줘야한다
	* date -(to_char)→ **character** -(to_number)→ number
	* number -(to_char)→ **character** -(to_date)→ date
	* to_char(number, fmt), to_char(date, fmt)
	* to_number(char, fmt)
	* to_date(char, fmt)
* to_char(날짜, '날짜 형식') : 날짜 > 문자
	* 포맷 모델은 홑따옴표 안에 둘러 싸여 있고, 대소문자를 구분한다.
	* 연도 YYYY or YY / 월 MM / 날짜(년, 월, 주의 일) DDD or DD or D
	* 시간 HH or HH12 or HH24 / 분 MI / 초 SS

* to_number(숫자, '문자 형식') : 문자 > 숫자
	* 자동으로 형변환이 되는 경우가 있기 때문에 잘 쓰지는 않는다
	* 달러나 콤마가 들어있는 유형의 문자 빼고는 자동으로 형변환이 된다
	* 달러나 콤마가 들어있는 유형의 문자를 처리할 수 있다

* to_date(문자, '날짜 형식')


### NVL
* null 값을 실제 값으로 변환할 때 사용, 날짜/문자/숫자 사용
* NVL(A, B) : A가 NULL이 **아니면** A, NULL이면 B 출력

### NVL2
* NVL2(A, B, C) : A가 NULL이 **아니면** B, NULL이면 C

### decode  ★★★★★
* if-then- else 구문
* decode(a,b,c,
	  d,e,
	  f)
	* a식의 값이 b와 같으면 c 출력
	* b와 다르고 d와 같다면 e 출력
	* d와도 다르다면 default 값인 f 출력

### CASE ~ WHEN ~ THEN
* JAVA의 IF~ELSE문 or SWITCH~CASE문
* CASE절에 표현식이 있으면 WHEN 절에 값이 오고
* CASE절에 표현식이 없으면 WHEN 절에 조건식이 온다


### 210401

## 함수
### 집합연산자
#### union : 합친다 + 중복X
#### union all : 합친다 + 중복O
* union이나 union all은 듀얼테이블(가상테이블)로 만들어서 사용하는 경우가 많다
* 두 결과의 컬럼 개수가 일치해야 한다
#### intersect (교집합)
#### minus (차집합)

## 그룹함수
* 대표적인 그룹함수 : AVG, SUM, MIN, MAX, COUNT
	* 단일 그룹의 그룹 함수
	* 일반 컬럼과 함께 출력할 수 없다
	* NULL 값을 무시하고 계산한다 (COUNT는 포함해서 계산)
	* 문자와 날짜에 대해서도 MIN, MAX 값을 구할 수 있다

* COUNT의 두가지 형식
	* COUNT(*) : 중복값과 NULL값을 포함해 행의 수 리턴
	* COUNT(expre) : expr(열, 컬럼)에서 NULL 값이 아닌 행의 수 리턴 
### GROUP BY
* WHERE절과 ORDER절 사이에 작성한다
* 일반 컬럼과 그룹 함수를 함께 사용할 수 없기 때문에 GROUP BY로 묶어줘야 한다
* WHERE 절에서 그룹함수를 사용할 수 없다

### HAVING
* GROUP BY의 조건
* WHERE는 일반 열에 대한 조건, HAVING 절은 그룹화된 열에 대한 조건
* HAVING절에서는 그룹함수로 제어할 수 있다
* 그룹함수 뒤에 OVER()를 쓰면 예외적으로 그룹화해도 일반 컬럼과 함께 출력할 수 있다
* not like 'sa%' : sa로 시작하지 않는

## JOIN이란?
* 관계형 데이터베이스에서 가장 중요한 개념
* 테이블이 서로 연관이 있을 때 붙여서 하나로 가져온다(사용한다)
* PK와 FK
* 오라클 전용 JOIN과 모든 DB에서 똑같이 사용 가능한 ANSI JOIN이 있다
	* ANSI JOIN을 배울 것

### 중요 조인의 종류
* 완벽하게 개념을 알아야한다!
* 형식 : FROM (table이름) JOIN (table이름) ON (연결조건)

#### INNER JOIN : 내부 조인 = EQUALS JOIN
* INNER 생략 가능 > 그냥 JOIN = INNER JOIN
* **NULL 값은 반환되지 않는다**
* 구문 select * from info INNER JOIN user ON info.id=user.id;
* USING절을 이용하면 **원하는 컬럼에 대해서만** 선택적으로 INNER JOIN을 할 수 있다
	* 만약 두 테이블에 또 다른 컬럼이 있다면 각각 나온다
* ON절은 다른 컬럼에 대해서 JOIN이 가능하다
* WHERE절을 사용하지 않고 ON 절에 일반 조건을 포함시킬 수 있다

#### OUTER JOIN : 외부 조인
* 특징 : **null 값이 반환된다**
* LEFT : 왼쪽 테이블을 기준으로 오른쪽 테이블을 붙인다
	* 왼쪽 테이블의 크기가 더 크면 오른쪽 테이블 행이 차이만큼 null로 채워져서 반환된다
* RIGHT : LEFT OUTER JOIN과 반대
* FULL : 양쪽 기준으로 다 나옴

#### CROSS JOIN : 잘못된 JOIN의 형태
* 두 테이블의 카디션 프로덕트
* 한 테이블의 한 행당 다른 테이블의 모든행이 나옴
* 더미 데이터를 만들 때 사용한다
* CARTESIAN PRODUCT가 발생하는 경우
	* 조인 조건이 생략된 경우
	* 조인 조건이 잘못된 경우
	* 첫 번째 테이블의 모든행이 두번째 테이블의 모든 행과 조인되는 경우

#### SELF JOIN : 하나의 테이블끼리 JOIN 


### 210402
## 그룹함수 복습
### department_id로 그룹핑했으면 select 절에도 department_id가 나와야된다

## join
* join만 쓰면 inner join
* cross join(cartisian product)는 안쓰는 게 바람직하다
	* join 조건을 잘못 입력한 경우에 발생한다
* self join : 같은 테이블에 join을 함

## 서브쿼리
* 단일행(값이 하나)이냐 다중행(값이 여러개)이냐에 따라 사용하는 연산자가 다르다

### 단일행 서브쿼리
* 내부 select 문장으로부터 하나의 행을 리턴
* 단일행 연산자를 사용한다 : >, =, >=, <, <>, <=

### 다중행 서브쿼리
* 다중행 연산자를 사용한다 : IN, ANY, ALL (외우기)
	* IN : 정확히 일치
	* ANY : 
		* <ANY : 최댓값보다 작다
		* >ANY : 최솟값보다 크다
	* > ALL : 최대갓값보다 크다
	* < ALL : 최솟값보다 작다

### 스칼라 서브쿼리
* 이걸 잘 쓰면 성능이 좋아짐!


### 210405

## 서브쿼리
* WHERE, SELECT, FROM 중 어디에 들어가느냐에 따라 이름이 다르다
	* WHERE : 일반적인 서브쿼리 절
	* SELECT : 스칼라 쿼리라고 부르고
	* FROM : 인라인 뷰라고 부른다

### 스칼라 서브쿼리
* SELECT 절에 사용하는 서브쿼리
* 결과가 다중행이면 안되고, 열 개수도 2개 이상 뽑으면 안된다
	* 뽑는 구문이 있지만 일반적으로 단일값으로 나오게 해야한다
* 잘 쓰면 성능 효율이 높아진다
```sql
select d.*
	(가져오고 싶은 테이블의 단일 행 결과를 가져오는 서브쿼리)
from departments;
↓
select d.*
	(select e.first_name
	 from employees e
	 where d.manager_id = e.employee_id)
from departments;
```

### 인라인 뷰 ☆☆☆
* 많이 쓰이는만큼 엄청 중요하다
* from절에 들어가는 인라인 뷰
	* 왜 뷰인가? from절에는 테이블이 들어가는데 서브쿼리로 가상의 뷰를 만들어 들어간다
* 필요한 데이터(값)을 만들어서 가져와 전체 select에서 사용할 수 있다
* rownum은 첫번째 행부터 조회할 수 있다

### 210406

## DML(Data Manipulation Language)
* DML 구문에서만 트랜잭션을 사용할 수 있다.
	* 트랜잭션은 안전장치다 라고 정도만 생각해
### INSERT
#### INSERT INTO table (columns...) VALUES (values...)
* 넣고 싶은 컬럼을 결정할 수 있다.
#### INSERT INTO table VALUES (values...)
* 통째로 다 넣는 방법

* INSERT만 한 건 입력을 한게 아니고 트랜잭션에 기록만 한 상태!
* INSERT를 넣기 전으로 되돌리는 ROLLBACK을 할 수 있다
* WHERE 절에 
	* 1=1 : TRUE : 값까지 모두 복사해서 똑같은 TABLE을 만든다
	* 1=2 : FALSE : 구조만 복사해서 TABLE을 만든다

### UPDATE
#### UPDATE table SET column = value WHERE ...
##### WHERE  절 꼭!! 넣어주기 ☆☆☆
##### SELECT 문장을 선행해서 업데이트 할 문장을 한 번 보고 업데이트해야된다

### DELETE
#### DELETE FROM table WHERE ...
* 참조 무결성 제약 조건에 주의 해야한다
	* 다른 테이블에 참조되고 있는 레코드가 있으면 안지워진다
* PK로 삭제하는 게 일반적

### 210407

## DML - MERGE
#### MERGE INTO (target table) USING ... ON (join condition)
#### WHEN MATCHED THEN - 일치했을 때 수행할 구문
#### WHEN NOT MATCHED THEN - 일치하지 않을 때 수행할 구문

## 트랜잭션
* 논리적인 작업의 단위
* EX) 500 출금 > 존재 확인 > 본인 확인 > 비번 확인 > 잔고 > 출금
* DML로 만든 테이블은 실제로 반영된 상태는 아니고 **기록**만 해놓은 테이블
* COMMIT이 되어야 진짜 반영된 것이고, 이렇게 반영된 후에는 절대 다시 ROLLBACK할 수 없다
* ROLLBACK은 최종 COMMIT이 반영된 곳으로 돌아갈 수 있다
### SAVEPOINT savepointName
* ROLLBACK 실행하면 SAVEPOINT로 돌아간다
* 많이 쓰진 않는다

## 테이블 생성 (CREATE TABLE)
* 스키마 : DB의 정보들의 집합, 소유자의 이름과 똑같다
### 데이터 타입
* VARCHAR2(size) : 최소 1 ~ 최대 4000byte의 가변 길이 문자 데이터
	* ex) VARCHAR(1000)이지만 최대 1000byte까지 저장되지만 5byte 크기의 값을 저장하면 5byte 크기로 저장된다
* CHAR(size) : 고정 문자열, 최소 1 ~ 최대 2000byte
* NUMBER(p,s) 
* DATE
* BLOB : 사진과 동영상은 (아주 긴 or 큰) 이진 데이터를 갖고 있는데, 이렇게 큰 데이터를 저장할 때 사용한다

## 테이블 구조 변경 (ALTER TABLE)
* 열 이름 변경 
### ALTER TABLE table name RENAME COLUMN 

## 테이블 삭제 (DROP TABLE)
* 연습할 때나 해보는 거지 건들지 말아라..
* PK를 FK로 사용 중일 때에는 한 번에 DROP이 안된다
	* 이때 사용하는 것이 CASCADE ..이것도 위험.. 건들지 말아라..

## 테이블 데이터 비우기 (TRUNCATE)
* 테이블은 남기고 테이블의 모든 행을 삭제한다

## 제약 조건
* 다 외우기
#### NOT NULL : NULL 값을 포함하지 않음을 지정
#### UNIQUE KEY : 고유하게 중복데이터가 들어가는 것을 방지하는 제약 조건
* 여러 컬럼을 지정할 수 있다
#### PRIMARY KEY : 유일하게 테이블의 각 행을 식별
* 자동으로 NOT NULL + UNIQUE KEY를 갖는다
* 하나의 컬럼만 지정할 수 있다
#### FORIEGN KEY : 다른 테이블의 PK를 가져다 쓰는 것
* 제약 조건 이름을 만들고 싶으면 constraint ... 라고 써야한다
* 쓰지 않으면 자동으로 이름을 만들어 준다.

### 210408
## 복습
* PRIMARY KEY는 테이블에 꼭 하나씩 존재해야 한다
	* 테이블을 식별할 수 있어야하기 때문에
	* 없으면 자동으로 만들어진다
* 열 레벨 제약조건과 테이블 레벨 제약조건이 있다

## 제약조건 종류
* 개체 무결성 조건 : PRIMARY KEY를 위반하는 행동을 위반하는 제약 조건
	* PK에 대해서 NULL 값이나 중복값이 들어갔을 때 발생

* UNIQUE : 중복 방지, NULL은 가능
* PK : 중복 X, NULL X
* 참조 무결성 제약 조건 : 참조 하고 있는 테이블의 PK에 해당하는 데이터가 없을 때 발생하는 제약 조건
	* NULL 값은 들어갈 수 있다

## 제약조건 관리
* 제약 조건 수정은 안된다, 삭제 했다가 다시 만들어야 함
* 추가 : ALTER TABLE ~ ADD
* 삭제 : DROP (KEY 이름)

## 뷰(View)
* 가상의 테이블
* 테이블에 저장되어 있는 데이터들은 형체를 갖고 있는 물리적 데이터이다
* 논리적 테이블, 가짜 테이블, 복사본 테이블, 가상 테이블
* 왜 이런 테이블을 만들까?
	* 필요한 자료를 빨리 보기 위해서 만들어 쓰는 것
* 단순 뷰 : 한 개의 원본테이블을 사용해서 생성
* 복합 뷰 : 두개 이상의 원본 테이블의 조인을 통해 생성
* 업데이트할 때 제약사항이 따른다
* 뷰도 만들려면 생성 권한이 필요하다
	* 지금은 권한이 있기 때문에 신경 쓰지 않아도 된다.
	* 권한이 있어야한다는 것만 기억해둬
* 생성 & 삭제만 알면 된다
### CREATE VIEW
* OR REPLACE는 붙여도 되고 안붙여도 된다
* 다른 테이블을 참조해서 만드는 거라서 AS 뒤에 서브쿼리를 붙인다
* 물리적 테이블을 참조해서 만드는 거라 구조까지 복사해서 가져온다
* 함수나 가상표현으로 컬럼이름을 만들 수 없고 무조건 alias로 이름을 붙여줘야 한다
* RESOURCE라는 권한을 갖고 있다 = 웬만한 건 다 할 수 있다
* 뷰의 데이터를 변경시키면 원본 데이터도 변경시킨다

### 수정
* 삭제하지 않고 CREATE 문처럼 만들면 수정이 된다

### 뷰의 규칙 정리
* 단순 뷰에서 DML 연산을 수행할 수 있다

## 뷰를 이용한 DML 연산 인라인 뷰
* 읽기 전용 뷰 - WITH READ ONLY
* 조건을 걸어 해당 컬럼에 접근 금지 - WITH CHECK OPTION

## 인라인 뷰
* FROM 절에 사용하는 가상의 테이블
* 스키마 객체(물리적 객체)가 아니다

## SEQUENCE (순차적으로 증가하는 값)
* 1씩 증가하는 PRIMARY KEY 값을 생성하기 위해 사용
* 한번만 만들어놓으면 자동으로 얼만큼씩 증가한다
* 하나의 객체처럼 만들어놓고 만들어놓은 SEQUENCE를 테이블에 적용시켜 사용한다
### SEQUENCE 생성
* CREATE SEQUENCE (이름); 이렇게만 써도 자동으로 설정돼서 만들어짐
* 추가적으로 옵션을 달 수도 있음
	* INCREMENT BY n : n씩 증가
	* START WITH n : n에서 시작
	* MAXVALUE / MINVALUE
	* CYCLE : 싸이클 여부, 숫자가 끝까지 돌면 어떻게 할 거냐
		* 최대값에 도달하면 다시 최솟값부터 시작
	* CACHE / NOCACHE : 자주 사용하는 기능은 가까이 복사해놓을 수 있다
### 함수
* NEXTVAL : 다음 사용 가능한 시퀀스 값 리턴
	* 반복자 같은 개념
* CURRVAR : 현재 시퀀스 값 리턴
	* 현재 시퀀스 값을 보고 싶을 때 사용하는 듯

### SEQUENCE 변경
#### ALTER SEQUENCE (이름) (바꿀 내용);

## INDEX
* 테이블에서 원하는 레코드(행)을 빠르게 찾아갈 수 있는 자료구조
* PRIMARY KEY나 UNIQUE에 의해 자동적으로 생성된다
* 조회 속도가 빠르다
* 수정, 삭제, 추가의 경우에는 INDEX가 없는 게 효율적이다
* 공간의 낭비와 효율성을 생각하며 만들어야한다
* 정리하자면
	* 수정, 삭제, 추가가 많이 일어나면 INDEX를 만들지 않는다
	* 많이 일어나지 않는 경우에 INDEX를 만들어 사용한다
* 인덱스는 삭제해도 테이블에 아무런 영향을 미치지 않는다

### 예상질문
* 잘 돌아가는데 느려요~~ 뭘 확인해볼까요?
	* CPU
	* SQL문을 비효율적으로 짰는지 확인해본다
		* 조회, 변경하는 작업에 INDEX를 사용하고 있는지
		* PK를 사용해 INDEX 조회를 하고 있는지
		* 비효율적으로 INDEX가 많이 사용하고 있는지
		* 스칼라 쿼리문이 비효율적으로 작성되었는지 확인해본다

### 210409

## 권한
* 권한은 hr 계정으로 줄 수 없고
* PDB에 sys 계정으로 들어가서 줘야 한다
### 사용자 계정 생성 
* 형식 : CREATE USER (NAME) IDENTIFIED BY (PW);
* 아무 권한이 없는 사용자 계정
### 생성된 계정에 권한 부여
* DCL - Database Control Language
* 형식 : GRANT ... TO ... (user_name)
* 권한 생성 명령은 높은 자리까지 가지 않는 한 많이 사용하지는 않을 듯
### 시스템 권한
* CREATE SESSION : DB 접속 가능 권한
	* 계정 생성 시 이 권한이 없다면 접속조차 안된다
* CREATE TABLE, SEQUENCE, VIEW : TABLE, SEQUENCE, VIEW를 만들 수 있는 권한
* CREATE PROCEDURE : 절차형 DB를 쓸 수 있는 권한

* C:\app\user\product\18.0.0\oradata\XE\XEPDB1
	* 데이터가 저장되는 물리적 공간이다
	* DBF 파일로 저장된다
	* 새로 만든 사용자 계정에 권한을 주었지만 INSERT가 안되는 이유?
		* 이 물리적 공간에 연결을 안해줬기 때문이다
		* 연결된 DBF 파일이 없기 때문이다
* 계정 생성과 권한 부여 및 회수, 테이블스페이스 지정을 마우스로 할 수 있다
* 보기 > DBA > +(새 접속) > PDB로 접속
* 저장 영역 > 테이블 스페이스 > 파일 
	* TEMP 는 복사본을 저장하는 곳
* DBA 잠깐 두고 PDB > 다른 사용자 > 우클릭 > 사용자 생성 > USERS, TEMP

* 테이블스페이스 생성
* 사용자 생성
* 부여된 롤 > CONNECT, RESOURCE 체크
* 할당량 무제한으로 설정

* 그 전에 ROLE을 알아보자
	* CONNECT
	* RESOURCE
	* DBA
* ROLE을 이용하면 모든 권한을 간단하게 줄 수 있다
* GRANT CONNECT, RESOURCE 까지 하면 CREATE PROCEDUER라는 권한 빼고 모두 부여된 것이다

## 데이터베이스모델링 = 데이터베이스 설계 방법
* 업무파악
* 개념적 데이터 모델링 - ER 다이어크램 작성
* 논리적 데이터 모델링 - 테이블 작성
* 물리적 데이터 모델링 ㅇ

### 업무 작성
* 화면 정의 기획서
### 개념적 데이터 모델링
* 만들어진 계획서를 보고 필요한 것과 그것들이 어떤 상호작용을 하는 지 파악하는 것
* 화면에 필요한 데이터를 생각해보고 컬럼으로 분리한다
* 주제에 따라 중복을 제거하고 만든다
#### ER 다이어그램 그리기
* ENTITY(개체)는 네모 박스로 표현
* ATTRIBUTE(속성)은 동그랗게 표현 - 컬럼이 된다
* RELATION(관계)은 마름모로 표현, ENTITY간의 관계를 표현
	* PK, FK로 연결된다
* 이렇게 그림만 그려선 정확하게 알 수가 없어서 카디널리티로 표시해줘야한다.
#### Cardinality (관계 대응 수)
* 1:1 - 하나의 행에 대해서 하나의 행에 연결
* 1:n
* n:m

#### Optionality
* entity와 entity의 필수, 옵션을 표기
* 부서 - 직원 : 부서에게 직원은 옵션(ㅇ), 직원에게 부서는 필수(|)

* n:m 관계는 테이블로 만들 수 없다
	* 1:n으로 바꿔줄 수 있는 mapping table을 만들어야한다
	* n:m 관계일 때는 어느 쪽에도 FK를 설정할 수가 없다
	* 맵핑 테이블은 두 키를 한 번에 PK로 쓴다 = SUPER KEY를 PK로 쓴다

* 과제 13P 몇대몇 관계인지 확인해보기 

### 210412

## 데이터베이스모델링
### 개념적 데이터 모델링
* 나중에는 생략할 수도 있다
#### 1:1 관계 - 외래키를 부테이블에 잡는다
#### 1:N 관계 - N 쪽에 외래키를 잡는다
#### N:M 관계
* N:M 관계는 꼭 1:N으로 바꿔줘야 한다 - 해결 방법
	1. 맵핑 테이블을 만든다
	2. 양쪽의 PK를 가져와 FK로만 이루어진 테이블을 만든다
	3. 두 키를 슈퍼키로 해 PK로 잡는다
	4. 새로운 번호를 붙여 PK로 잡을 수도 있다.

### 논리적 데이터 모델링
* 개념적 모델링으로 만들어진 다이어그램을 가지고 표로 변환하는 작업
* 이클립스에 무료 ERD 프로그램이 있다 - ER MASTER (ER WIN도 있다)
	1. JAVA에서 ERDMaster를 설치한다
	2. 새 JAVA 프로젝트의 src > other 에서 er 이라고 검색해서 나온 것을 설치한다
#### 테이블 정규화 
* 3형 정규화 이상은 완전 원자 분해가 돼서 다시 합칠 때 힘들다
* 제 1정규화 : 도메인이 원자 값
* 제 2정규화 : 부분적 함수 종속 제거
* 제 3정규화 : 이행적 함수 종속 제거

### 210413

## 복습
* 제 1형 정규화 : 한 튜플은 한 개의 값, 원자값을 가져야 한다
* 제 2형 정규화 : 한 개의 PK에 대해 종속되는 경우가 2가지 (이상?) 
* 제 3형 정규화 : PK가 두개인 경우
* BCNF : 결정자가 KEY여야한다
* 여기까지 하면 어느 정도 완료된다

## 물리적 데이터베이스 모델링
* FK를 생략하기도 한다 WHY?
	* 테이블 관계에서 제약조건이 너무 많이 생기기 때문에
	* 데이터의 무결성에 대해 정확하게 지켜야할 때만 사용한다

### 210415

## PL/SQL
* Program Language SQL
* 변수, switch, if문 등 일반적인 프로그래밍 언어의 개념이 다 들어있다

### 210419

## 트리거
* 트리거는 테이블에 DML 구문이 적용이 됐을 때 특정 코드를 붙여서 사용
* 자동으로 동작되게 함
* 프로시저랑은 다름 
* 프로시저는 내가 직접 함수처럼 만들어놓고 순서대로 일련의 작업을 할 때 사용

### AFTER 트리거 
* DML 구문이 실행된 다음에(직후에) 실행된다
* DELETE, UPDATE 구문에 주로 사용한다

### BEFORE 트리거
* INSERT로 들어가기 이전에(직전에) 실행된다
* INSERT문에 주로 사용한다

### 변수참조 키워드
* :OLD - 참조 전 column 값, 기존 값
* :NEW - 들어오는 값
* INSERT는 :NEW만 사용 가능
* UPDATE, DELETE는 :OLD, :NEW 모두 사용 가능

### 주문 프로세스
* 주문기록 테이블에 트리거를 붙여놓으면 자동으로 상품 테이블에서 -가 된다

## 테스트
* 프로시저 : 특정 작업을 수행하는 PL/SQL 블록, 매개변수를 받을 수 있고 반복적으로 사용할 수 있다
* 트리거 : 특정 테이블에서 DML문이 수행되었을 때 DB에서 자동으로 동작하도록 작성된 프로그램
* 차이점 : 프로시저는 매개변수를 전달할 수 있지만 트리거는 매개변수를 전달할 수 없고, 프로시저는 값을 반환할 수 있지만 트리거는 반환할 수 없다.


