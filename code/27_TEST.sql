-- TEST

-- 문제6) 프로시저명 gugu_proc구구단 을 입력받아 해당 단수를 출력하는 procedure을 생성하세요.
CREATE OR REPLACE PROCEDURE GUGU_PROC 
    (DAN NUMBER
    )
IS
    I NUMBER := 1;
BEGIN
    WHILE I < 10
    LOOP
        DBMS_OUTPUT.PUT_LINE(DAN || ' X ' || I || ' = ' || DAN*I);
        I := I + 1;
    END LOOP;
END;

EXEC GUGU_PROC(3);

-- 문제7) 프로시저명 depts_proc을 작성하세요
-- 1. DEPARTMENTS 테이블을 복사해 DEPTS 테이블 생성
CREATE TABLE DEPTS AS SELECT * FROM DEPARTMENTS WHERE 1 = 1;

--2. DEPARTMENT_ID에 PRIMARY KEY 추가
ALTER TABLE DEPTS ADD CONSTRAINT DEPTS_DEPARTMENT_ID_PK PRIMARY KEY (DEPARTMENT_ID);

--3. FLAG 변수 설정
CREATE OR REPLACE PROCEDURE DEPTS_PROC 
    (DEPTS_ID IN DEPTS.DEPARTMENT_ID%TYPE,
     DEPTS_NAME IN DEPTS.DEPARTMENT_NAME%TYPE,
     FLAG CHAR
    )
IS
BEGIN
    IF FLAG = 'I' THEN
        INSERT INTO DEPTS(DEPARTMENT_ID, DEPARTMENT_NAME) VALUES (DEPTS_ID, DEPTS_NAME);
    ELSIF FLAG = 'U' THEN
        UPDATE DEPTS 
        SET DEPARTMENT_NAME = DEPTS_NAME 
        WHERE DEPARTMENT_ID = DEPTS_ID;
    ELSIF FLAG = 'D' THEN
        DELETE FROM DEPTS WHERE DEPARTMENT_ID = DEPTS_ID;
    COMMIT;
    END IF;
    
    EXCEPTION WHEN OTHERS THEN
        DBMS_OUTPUT.PUT_LINE('예외가 발생했습니다.');
        ROLLBACK;
END;

EXEC DEPTS_PROC(60, 'IT_BANK', 'I');

-- 문제 8) 프로시저명 - emp_hiredate_proc
SET SERVEROUTPUT ON;
CREATE OR REPLACE PROCEDURE EMP_HIREDATE_PROC
    (EMP_ID IN EMPLOYEES.EMPLOYEE_ID%TYPE,
     EMP_TOTAL_YEAR OUT NUMBER
    )
IS
    V_COUNT NUMBER := 0;
    V_TOTAL_YEAR NUMBER := 0;
BEGIN
    SELECT COUNT(*)
    INTO V_COUNT
    FROM EMPLOYEES
    WHERE EMPLOYEE_ID = EMP_ID;
    
    IF V_COUNT = 0 THEN
       DBMS_OUTPUT.PUT_LINE(EMP_ID || ' 값이 없습니다.');
       RETURN; -- 프로시저 종료
    ELSE
        SELECT TRUNC((SYSDATE - HIRE_DATE)/365)
        INTO V_TOTAL_YEAR
        FROM EMPLOYEES
        WHERE EMPLOYEE_ID = EMP_ID;
    END IF;
    
    EMP_TOTAL_YEAR := V_TOTAL_YEAR;
    
    EXCEPTION WHEN OTHERS THEN
        DBMS_OUTPUT.PUT_LINE('예외가 발생했습니다');
END;

DECLARE
    TOTAL_YEAR NUMBER;
BEGIN
    EMP_HIREDATE_PROC(100, TOTAL_YEAR);
    DBMS_OUTPUT.PUT_LINE(TOTAL_YEAR);
END;

-- 문제 9) 프로시저명 - emp_merge_proc
--1) EMPLOYEES 복사테이블 생성
CREATE TABLE EMPS AS SELECT * FROM EMPLOYEES WHERE 1=1;

--2) MERGE문 작성
CREATE OR REPLACE PROCEDURE EMP_MERGE_PROC
    (EMP_ID IN EMPLOYEES.EMPLOYEE_ID%TYPE,
     EMP_NAME IN EMPLOYEES.LAST_NAME%TYPE,
     EMP_EMAIL IN EMPLOYEES.EMAIL%TYPE,
     EMP_HIREDATE IN EMPLOYEES.HIRE_DATE%TYPE,
     EMP_JOB_ID IN EMPLOYEES.JOB_ID%TYPE
    )
IS
    V_COUNT NUMBER := 0;
BEGIN
    SELECT COUNT(*)
    INTO V_COUNT
    FROM EMPS
    WHERE EMPLOYEE_ID = EMP_ID;
    
    IF V_COUNT = 0 THEN 
        INSERT INTO EMPS (EMPLOYEE_ID, LAST_NAME, EMAIL, HIRE_DATE, JOB_ID) 
        VALUES (EMP_ID, EMP_NAME, EMP_EMAIL, EMP_HIREDATE, EMP_JOB_ID);
    ELSE
        UPDATE EMPS SET LAST_NAME = EMP_NAME WHERE EMPLOYEE_ID = EMP_ID;
        UPDATE EMPS SET EMAIL = EMP_EMAIL WHERE EMPLOYEE_ID = EMP_ID;
        UPDATE EMPS SET HIRE_DATE = EMP_HIREDATE WHERE EMPLOYEE_ID = EMP_ID;
        UPDATE EMPS SET JOB_ID = EMP_JOB_ID WHERE EMPLOYEE_ID = EMP_ID;
    END IF;

END;

EXEC EMP_MERGE_PROC(100, 'Kim', 'SKIM', SYSDATE, 'IT_PROG');

SELECT * FROM EMPS;

-- 쌤코드
-- Merge문을 배웠구나...
/*
MERGE INTO 타겟 A
    USING ()
    ON ()
WHEN MATCHED THEN

WHEN NOT MATCHED THEN
*/
-- 기존 자료를 업데이트, 없으면 인서트

-- 타겟 테이블이 EMPS 테이블
CREATE OR REPLACE PROCEDURE EMP_MERGE_PROC_T
    (P_EMP_ID IN EMPS.EMPLOYEE_ID%TYPE,
     P_LAST_NAME IN EMPS.LAST_NAME%TYPE,
     P_EMAIL IN EMPS.EMAIL%TYPE,
     P_HIRE_DATE IN EMPS.HIRE_DATE%TYPE,
     P_JOB_ID IN EMPS.JOB_ID%TYPE
    )
IS
BEGIN
    MERGE INTO EMPS A
    USING (SELECT P_EMP_ID AS EMPLOYEE_ID FROM DUAL) B
    ON (A.EMPLOYEE_ID = B.EMPLOYEE_ID)
    WHEN MATCHED THEN
        UPDATE SET A.LAST_NAME = P_LAST_NAME,
                   A.EMAIL = P_EMAIL,
                   A.HIRE_DATE = P_HIRE_DATE,
                   A.JOB_ID = P_JOB_ID
        /*WHERE A.EMPLOYEE_ID = P_EMP_ID*/
    WHEN NOT MATCHED THEN
        INSERT (A.EMPLOYEE_ID, A.LAST_NAME, A.EMAIL, A.HIRE_DATE, A.JOB_ID)
        VALUES (P_EMP_ID, P_LAST_NAME, P_EMAIL, P_HIRE_DATE, P_JOB_ID);
END;

EXEC EMP_MERGE_PROC(110, 'HONG', 'HONG@NAVER', SYSDATE, 100);

SELECT * FROM EMPS;

-- 제10) 프로시저명 - sales_proc
CREATE TABLE SALES (
    SNO NUMBER(5), -- 번호
    NAME VARCHAR2(30), --상품명
    TOTAL NUMBER(10), --수량
    PRICE NUMBER(10), --가격
    REGDATE DATE DEFAULT SYSDATE REFERENCES DAY_OF_SALES(REGDATE)-- 날짜
);

CREATE TABLE DAY_OF_SALES (
    REGDATE DATE PRIMARY KEY,
    FINAL_TOTAL NUMBER(10)
);

DROP TABLE DAY_OF_SALES;

CREATE OR REPLACE TRIGGER SALES_PROC
    AFTER INSERT
    ON SALES
    FOR EACH ROW
DECLARE
    V_COUNT NUMBER(10) := 0;
    V_TOTAL NUMBER(10) := :NEW.TOTAL;
    V_PRICE NUMBER(10) := :NEW.PRICE;
    V_REGDATE DATE := :NEW.REGDATE;
BEGIN
    SELECT COUNT(*)
    INTO V_COUNT
    FROM DAY_OF_SALES
    WHERE REGDATE = V_REGDATE;
    
    IF V_COUNT = 0 THEN
        INSERT INTO DAY_OF_SALES VALUES (V_REGDATE, V_TOTAL*V_PRICE);
    ELSE
        UPDATE DAY_OF_SALES
        SET FINAL_TOTAL = FINAL_TOTAL + V_TOTAL*V_PRICE
        WHERE REGDATE = V_REGDATE;
    END IF;
END;

INSERT INTO SALES VALUES (1, 'BOOK', 1, 10000, TO_DATE('21/04/18'));
INSERT INTO SALES VALUES (2, 'MOUSE', 2, 10000, TO_DATE('21/04/18'));
INSERT INTO SALES VALUES (3, 'NOTEBOOK', 3, 1000, SYSDATE);
INSERT INTO SALES VALUES (4, 'CUP', 4, 5000, SYSDATE);

SELECT * FROM DAY_OF_SALES;

-- 쌤 코드
CREATE OR REPLACE PROCEDURE SALES_PROC
    (P_REGDATE IN SALES.REGDATE%TYPE -- 날짜 파라미터
    )
IS
    V_FINAL_TOTAL NUMBER := 0; -- 일자별 총집합
BEGIN -- SALES의 날짜별 수량 합계
    SELECT SUM(TOTAL*PRICE) AS V_FINAL_TOTAL
    INTO V_FINAL_TOTAL
    FROM SALES
    WHERE TO_CHAR(REGDATE, 'YY/MM/DD') = TO_CHAR(P_REGDATE, 'YY/MM/DD');
    
    MERGE INTO DAY_OF_SALES A
    USING (SELECT TO_CHAR(P_REGDATE, 'YY/MM/DD') AS REGDATE,
                  V_FINAL_TOTAL AS V_FINAL_TOTAL
           FROM DUAL) B
    ON (TO_CHAR(A.REGDATE, 'YY/MM/DD') = B.REGDATE)
    WHEN MATCHED THEN
        UPDATE SET A.FINAL_TOTAL = V_FINAL_TOTAL
    WHEN NOT MATCHED THEN
        INSERT VALUES(P_REGDATE, V_FINAL_TOTAL);
END;

EXEC SALES_PROC(SYSDATE);

SELECT * FROM DAY_OF_SALES;